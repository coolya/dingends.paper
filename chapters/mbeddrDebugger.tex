\section{mbeddr Debugger Framework}
\label{mbeddrDebugger}
\label{mbeddrDebuggerFramework}

mbeddr comes with a debugger, which allows users to debug their mbeddr code 
on the abstraction levels of the used languages. For that, each language
contributes a debugger extension, which is build with a framework also provided
by mbeddr~\cite{DBLP:conf/adaEurope/AdaEuropeDeb}.
Debugging support is implemented specificly for the language by
lifting the call stack/program state from the base-level to the
extension-level (see \fig{infoFlow}) and stepping/breakpoints
vice versa.

\begin{figure}[h]
  \vspace{-2mm}
  \centering
    \includegraphics[width=5.5cm]{./figures/two-levels.png} 
    \vspace{-2mm}
    \caption{Flow of debug information between base and
    extension level~\cite{DBLP:conf/adaEurope/AdaEuropeDeb}}
  \label{infoFlow}
  \vspace{-2mm}
\end{figure}



The debugger framework can be separated into two different parts: First, a
\ac{DSL} and a set of interfaces (shown in \fig{specabs}) for specifying the
debugging semantics of language concepts. 
Second, a runtime for executing those specifications and
thus achieving the mapping described in~\fig{infoFlow}. 

In this paper, we focus only on the specification part (see
\fig{specabs}) required for understanding how the debugger extension
for unit testing is build.
Further details about the architecture and its implemention with \ac{MPS} are
described in \cite{DBLP:conf/adaEurope/AdaEuropeDeb}. 


\subsection{Breakpoints}
\ic{Breakable}s are concepts (\eg \ic{Statement}s) on which
we can set breakpoints to suspend the program execution.


\subsection{Watches}

\ic{WatchProvider}s are translated to low-level watches (\eg
\ic{GlobalVariableDeclaration}) or represent watches on the extension-level.
They are declared inside \ic{WatchProviderScope}s (\eg
\ic{StatementList}), which is a nestable context.

\subsection{Stepping} 
\ic{Steppable}s define where program execution must suspend
next, after the user \emph{steps over} 
an instance of \ic{Steppable} (\eg \ic{Statement}). If a
\ic{Steppable} contains a \ic{StepIntoable} (\eg \ic{FunctionCall}), 
then the \ic{Steppable} also supports \emph{step into}. \ic{StepIntoable}s are
concepts that branch execution into a \ic{SteppableComposite} (\eg \ic{Function}).

All stepping is implemented by setting low-level breakpoints and then resuming
execution until one of these breakpoints is hit (approach is based
on~\cite{Wu06grammar}). The particular stepping behavior is realized through 
stepping-related concepts by utilizing \ic{DebugStrategies}.

\subsection{Call Stack}
\ic{StackFrameContributor}s are
concepts that have callable semantics on the extension-level or are
translated to low-level callables (functions or procedures). While the latter do
not contribute any \ic{StackFrame}s to the high level call stack, the former
contribute at least one \ic{StackFrame}.

\begin{figure}[h]
  \vspace{-2mm}
  \centering
    \includegraphics[width=9cm]{./figures/debugger-concepts.png} 
    \vspace{-2mm}
    \caption{Meta-model used for specying the debugging semantics of language
    concepts~\cite{DBLP:conf/adaEurope/AdaEuropeDeb}. Colors indicate the
    different debugging aspects.} 
  \label{specabs}
  \vspace{-2mm}
\end{figure}

\section{Debugger Extension for Unit Testing}

This section describes the implementation of a minimal debugger
for the unit testing language, which is defined with mbeddr's debugger
specification \ac{DSL} and the abstractions shown in \fig{specabs}.

\subsection{Breakpoints}  To enable
breakpoints on instances of \ic{AssertStatement}, 
an implementation of the \ic{Breakable} interface is required. Since
\ic{AssertStatement} is derived from \ic{Statement} that already implements this
interface, thus breakpoints can be set on \ic{AssertStatement}.

\subsection{Call Stack}

\ic{TestCase} and \ic{ExecuteTestExpression} implement
\ic{StackFrameContributor} that are concepts translated to 
base-level callables. They contribute StackFrames, 
each is linked to a base-level stack frame and
states whether it is visible in the extension-level call stack or not.

The implementation of  \ic{ExecuteTestExpression} links the
low-level stack frame to the respective instance (see listing below).
Additionally, it declares to hide the stack frame 
from the high-level call stack.

\begin{lstlisting}[language=debuggerDSL,frame=single]
contribute frame mapping for frames.select(name=getName());
\end{lstlisting}

Similarly the mapping for \ic{TestCase} also requires linking the
low-level stack frame to the respective instance. However, 
it declares to \emph{show} the stack frame in the high-level call stack.
Further, we provide the name of the actual \ic{TestCase}, which is represented
in the call stack view: Consider \lst{lst:generatedUT}, where we would
lift the name \ic{test\_forTest} to \ic{forTest}.

\subsection{Stepping} 

\ic{AsserStatement} is a \ic{Statement}, which
already provides \emph{step over} behavior. However, to be able to 
\emph{step into} the \emph{condition} we overwrite \ic{Statement}'s 
\emph{step into} behavior: 
\begin{lstlisting}[language=debuggerDSL,frame=single]
break on nodes to step-into: this.expr;
\end{lstlisting}

\ic{break on nodes} searches in \ic{this.expr} (the assert's condition)
for instances of \ic{StepIntoable} and contributes their 
\emph{step into} strategies. Similar steps are taken to impment \emph{step into} 
for \ic{ExecuteTestExpression}.

\ic{TestCaseRef} implements \ic{StepIntoable} to allow 
\emph{step into} the referenced \ic{TestCase}. A  
minimal implementation puts
a breakpoint on the first statement in the \ic{Testcase} body:
\begin{lstlisting}[language=debuggerDSL,frame=single]
break on node: this.testcase.body.statements.first;
\end{lstlisting}

\subsection{Watches} 

Since \ic{ExecuteTestExpression}'s  stack frame is not shown in the high-level
call stack, none of its watches are mapped.
In contrast,  stack frames for \ic{TestCase}s are visible thus we need
to consider its watches. In case of \ic{TestCase}, the 
\ic{LocalVariableDeclaration} \_f has no corresponding representation on
the extension-level, therefore we hide it from the watches view (the C watch
would be shown otherwise):

\begin{lstlisting}[frame=single,language=debuggerDSL]
hide local variable with identifier "_f";
\end{lstlisting}