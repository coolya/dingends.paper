\section{Introduction}

Software development faces the challenge that \ac{GPL}
do not provide the appropriate abstractions for many domains 
in which they are used. Traditionally there are two major 
approaches to overcome this issue. One is to use frameworks 
that provide the domain-specific abstractions for the developer. 
This approach has very limited support for static semantics. 
Most \acp{GPL} do not support modification of constraints or type system. 
The second is to use external \acp{DSL} to give the developer a 
language for expressing solutions to domain problems. This approach 
has some other drawbacks. \todo{monolithic, all in advanced, central, foo bar}.
Language engineering with extensible languages provides a 
solution to theses problems. Instead of having a single 
monolithic \ac{DSL} extensible languages enable modular and 
incremental extension of a host language with domain specific 
abstractions~\cite{Voelter2011}. Those abstractions are incrementally
reduced to lower abstractions until they reach the 
abstraction level of a \ac{GPL}.

Debugging programs written with those language extensions at the same 
abstraction level as they have been defined in the model 
is crucial to the user. Because of this need, the debugger 
specification is a important part of the langauge specification. The 
information how the less domain specific extensions to the 
executed code has to be in place in the language extension. 
Description of the debugger behavior is done with a \ac{DSL} 
and is part of the language extension. The debugger description 
heavily relies on the mapping of the language extensions to the executed code.

Because language evolve over time and language extension can 
be based on other extensions it is essential to constantly 
test and monitor if the behavior of the debugger matched the 
expected behavior. In order to do so a language to describe 
the expected debugger behavior is needed.