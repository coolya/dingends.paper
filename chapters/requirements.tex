\section{Design Decisions}

Our testing \ac{DSL} targets debuggers for imperative extensible languages.
Those debuggers usually provide at least the following functionality:
show the call stack and program state in relation to the languages used, 
suspend the debugger on breakpoints and offer the possibility to 
step through the code. Our testing language must allow us to test at least those
four aspects. Based on those requirements we have defined some design
decision, which we will later implement in our language. While we consider 
some of those decisions as required, others are either optional or specific to mbeddr.

\subsection{Required}

\noindent \textbf{\label{R1}R1 Debug state validation:} In our test cases we
must be able to validate the call stack, and for each of its frames 
the program state and the location where suspended. 
The call stack itself is validated by specifying the expected stack
frames with their respective names. In terms of program state, we need to verify
the names of watchables and their respective values, which can either be simple
or complex. 
Finally, a location is specified, where the debugger is expected to suspend.

\noindent \textbf{\label{R2}R2 Debugger control:} In order to test stepping
commands and breakpoints, we need the ability to specify stepping commands
(in, over and out) and locations where to break.

\noindent \textbf{\label{R3}R3 Source language integration:} The
\ac{DSL} must integrate with the source language.
This integration is required for specifying in programs under test
locations to break (see \hyperref[R2]{R2}) and for validating where the debugger is suspended
(see \hyperref[R1]{R1}).

\subsection{Optional}
\noindent \textbf{\label{O1}O1 Reusability:} For writing debugger tests in
an efficient way, we expect from the language the ability to reuse: (1) test
data, (2) validation rules and (3) the structure of tests. First covers the ability to
have one mbeddr program to debug and write different debugger tests against
it. Second refers to reusing a set of validation rules in different test cases.
Consider different test cases testing stepping behavior inside the \ic{main} 
function of a C program.
As long as we stay inside the function, the call stack (stack frames, not the
location where suspended) would be the same for each test case. Hence, we could
write the C program and the call stack validation rule once, and refer to it
from each of our test cases. Finally, third, since we could even think about
writing an abstract test case, which is specialized by our concrete test cases.

\noindent \textbf{\label{O2}O2 Extensibility:} As discussed in
\hyperref[R1]{R1}, 
we expect from the \ac{DSL} the ability to validate the program state, location
where suspended and the call stack. In addition to this, we
require the ability to extend the language for contributing new
validation rules. Those new rules could be used for testing further debugger
functionality not covered by the testing language or for writing tests more
efficiently.

\noindent \textbf{\label{O3}O3 Automated test execution:} For getting fast
feedback about bugs introduced into debuggers, 
we require the ability to integrate our 
tests into an automatic execution environment. E.g., this environment can be
an \ac{IDE} or a command-line tool. 

\subsection{mbeddr-specific}
\noindent \textbf{\label{M1}M1 Exchangeability of debugger backends:}
mbeddr targets the embedded domain and C. In this domain, target platforms and
vendors require different compilers and debuggers. 
Hence, we require the ability to run our tests against
different debugger backends and on different platforms. To achieve this,
we expect from the \ac{DSL} the ability to specify the debugger backend
and the platform against/on which tests should executed.

% 
% \subsection{Functional Requirements}
% 
% The following list discusses the functional requirements we expect from a
% testing language for debuggers. While \hyperref[FR3]{FR3} is considered
% optional and \hyperref[FR3]{FR3} is mandatory in the embedded software domain,
% we expect \hyperref[FR1]{FR1} and \hyperref[FR2]{FR2} to be essential.
%  
% \noindent \textbf{\label{FR1}FR1 Debug state validation:} In our test cases we
% must be able to validate the call stack, and for each of its frames 
% the program state and the location where suspended. 
% 
% The stack itself should be validated by specifying the expected stack frames and
% their respective names. In terms of program state, we need to verify the names 
% of watchables and their respective values, with can either be simple or complex.
% Finally, location where suspended is a reference to a location inside the program under tests. 
% 
% \noindent \textbf{\label{FR2}FR2 Debugger control:} In order to test stepping
% commands and breakpoints, we need the ability to specify stepping commands
% (in, over and out) and locations where to break.
% 
% In a debugger test cases,
% first, the location where to break is specified. Next, after suspending on this
% location, an optional list of stepping commands is executed. Finally, after
% suspending, specified validation rules are evaluated.
% 
% \noindent \textbf{\label{FR2}FR2 Automated test execution:} Since we can write
% many different debugger tests, we require the ability to integrate our 
% tests into an automatic execution environment. This environment can be, \eg
% an \ac{IDE} or a command-line tool. Latter is preferred, since it can be
% executed on the local machine or on a build server.
% 
% \noindent \textbf{\label{FR3}FR3 Exchangeability of debugger backends:}
% mbeddr targets the embedded domain and C. In this domain, target platforms and
% vendors require different compilers and debuggers. 
% Hence, we require the ability to run our tests against
% different debugger backends and on different platforms. To achieve this,
% we expect from the \ac{DSL} the ability to specify the debugger backend
% and the platform against/on which tests should executed.
% 
% \subsection{Non-Functional Requirements}
% 
% In addition to the functional requirements discussed in the previous section, we
% have also defined non-functional requirements: \hyperref[NFR1]{NFR1} to
% \hyperref[NFR3]{NFR3}. While \hyperref[NFR2]{NFR2} can be considered optional,
% we consider \hyperref[NFR1]{NFR1} and \hyperref[NFR3]{NFR3} as mandatory for
% testing debugger implementations efficiently.
% 
% \noindent \textbf{\label{NFR1}NFR1 Reusability:} For writing debugger tests in
% an efficient way, we expect from the language the ability to reuse (1) test data, (2) 
% validation rules and (3) the structure of tests. First covers the ability to
% have one mbeddr program to debug and write different debugger tests against
% it. Second refers to reusing a set of validation rules in different test cases.
% 
% Consider different test cases testing stepping behavior inside the \ic{main} 
% function of a C program.
% As long as we stay inside the function, the call stack (stack frames, not the
% location where suspended) would be the same for each test case. Hence, we could
% write the C program and the call stack validation rule once, and refer to it
% from each of our test cases. Further, we could even think about writing
% an abstract test case, which is specialized by our actual test cases.
% 
% \noindent \textbf{\label{NFR2}NFR2 Extensibility:} As discussed in
% \hyperref[FR1]{FR1}, 
% we expect from the testing language the ability to validate the program state, location where
% suspended and the call stack. In addition to this, we
% require the ability to extend the testing language for contributing our own
% validation rules. Those new rules can be used for testing debugger
% functionality not covered by the language or for writing tests more efficiently.
% 
% \noindent \textbf{\label{NFR3}NFR3 Source language integration:} Finally,
% \ac{DSL} should integrate with programs written in the source language to debug.
% This integration is required for specifying locations to break and for
% validating where the debugger is suspended.
